<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Phi Cone Spirals — Polygon Arms on Adjustable Cone</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{
    margin:0;height:100%;
    background:#0b1020;color:#e8eefc;
    font-family:system-ui,Segoe UI,Roboto,sans-serif;
    overflow:hidden;
  }
  canvas{display:block}
  #ui{
    position:fixed;right:16px;top:16px;width:360px;
    background:rgba(25,28,40,.85);
    border:1px solid rgba(255,255,255,.1);
    border-radius:12px;padding:12px;
    backdrop-filter:blur(6px);box-sizing:border-box;
  }
  #ui h3{margin:0 0 8px;font-size:16px}
  .row{
    margin:8px 0;
    display:grid;
    grid-template-columns:1fr auto;
    gap:8px;
    align-items:center;
    font-size:13px;
  }
  .row input[type="range"],
  .row select{
    grid-column:1/3;
    width:100%;
    accent-color:#7aa2ff;
  }
  .row input[type="number"]{
    width:110px;
    background:#151826;
    border:1px solid rgba(255,255,255,.18);
    border-radius:6px;
    padding:3px 6px;
    color:#e8eefc;
    font-size:12px;
    box-sizing:border-box;
  }
  small{opacity:.7;line-height:1.2;font-size:11px}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="ui">
  <h3>Phi Cone Spirals</h3>

  <div class="row">
    <label>Polygon sides</label>
    <span id="sidesVal">6</span>
    <input id="sides" type="range" min="3" max="20" value="6">
  </div>

  <div class="row">
    <label>Iterations (φ steps)</label>
    <span id="itersVal">14</span>
    <input id="iters" type="range" min="2" max="30" value="14">
  </div>

  <div class="row">
    <label>Apex angle (°)</label>
    <input
      id="apexNumber"
      type="number"
      min="0"
      max="180"
      step="0.0000000001"
      value="60"
    >
    <input id="apexSlider" type="range" min="0" max="180" value="60">
  </div>

  <div class="row">
    <label>Direction</label>
    <select id="direction">
      <option value="in" selected>Inward (to apex)</option>
      <option value="out">Outward</option>
    </select>
  </div>

  <div class="row">
    <label>Show cone</label>
    <input id="showCone" type="checkbox" checked>
  </div>

  <small>
    Mouse drag: rotate • Wheel: zoom<br>
    Polygon sides = number of spiral arms.<br>
    Apex = 0° or 180° ⇒ flattened 2D φ-spirals.
  </small>
</div>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  const phi = (1 + Math.sqrt(5)) / 2;

  // UI elements
  const sidesInput = document.getElementById("sides");
  const sidesVal   = document.getElementById("sidesVal");
  const itersInput = document.getElementById("iters");
  const itersVal   = document.getElementById("itersVal");
  const apexSlider = document.getElementById("apexSlider");
  const apexNumber = document.getElementById("apexNumber");
  const dirSelect  = document.getElementById("direction");
  const showConeCheckbox = document.getElementById("showCone");

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05070f);

  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    5000
  );
  camera.position.set(0, 150, 320);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.target.set(0, -40, 0);

  const ambient = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambient);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(200, 300, 150);
  scene.add(dirLight);

  const spiralGroup = new THREE.Group();
  scene.add(spiralGroup);

  let coneMesh = null;

  function hookRangeDisplay(input, labelEl, onChange) {
    labelEl.textContent = input.value;
    input.addEventListener("input", () => {
      labelEl.textContent = input.value;
      onChange();
    });
  }

  hookRangeDisplay(sidesInput, sidesVal, rebuild);
  hookRangeDisplay(itersInput, itersVal, rebuild);

  // Sync slider <-> numeric input for apex angle
  function syncApexFromSlider() {
    apexNumber.value = apexSlider.value;
    rebuild();
  }

  function syncApexFromNumber() {
    let val = parseFloat(apexNumber.value);
    if (isNaN(val)) val = 0;
    if (val < 0) val = 0;
    if (val > 180) val = 180;
    apexNumber.value = val;
    apexSlider.value = val;
    rebuild();
  }

  apexSlider.addEventListener("input", syncApexFromSlider);
  apexNumber.addEventListener("input", syncApexFromNumber);

  dirSelect.addEventListener("change", rebuild);
  showConeCheckbox.addEventListener("change", rebuild);

  function clearGroup(group) {
    while (group.children.length > 0) {
      const obj = group.children.pop();
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
    }
  }

  function rebuild() {
    clearGroup(spiralGroup);
    if (coneMesh) {
      scene.remove(coneMesh);
      coneMesh.geometry.dispose();
      coneMesh.material.dispose();
      coneMesh = null;
    }

    const n          = parseInt(sidesInput.value, 10);
    const iterations = parseInt(itersInput.value, 10);
    const apexDeg    = parseFloat(apexNumber.value);
    const direction  = dirSelect.value;
    const showCone   = showConeCheckbox.checked;

    // Treat near-0 and near-180 as "flat 2D mode"
    const EPS = 1e-9;
    const isFlat = (apexDeg <= EPS || apexDeg >= 180 - EPS);

    const deltaTheta = (2 * Math.PI) / n;
    const maxTheta   = iterations * deltaTheta;

    const baseRadius = 100;

    let tanHalf = null;
    let coneHeight = null;

    if (!isFlat) {
      const apexRad   = (apexDeg * Math.PI) / 180;
      const halfAngle = apexRad / 2;
      tanHalf = Math.tan(halfAngle);
      coneHeight = baseRadius / tanHalf;

      if (showCone) {
        const coneGeo = new THREE.ConeGeometry(baseRadius, coneHeight, n, 1, true);
        // Move so apex is at y = 0, base at y = -coneHeight
        coneGeo.translate(0, -coneHeight / 2, 0);
        const coneMat = new THREE.MeshBasicMaterial({
          color: 0x444b66,
          wireframe: true,
          transparent: true,
          opacity: 0.35
        });
        coneMesh = new THREE.Mesh(coneGeo, coneMat);
        scene.add(coneMesh);
      }
    }

    function radiusForTheta(theta) {
      const power = theta / deltaTheta;
      if (direction === "in") {
        return baseRadius * Math.pow(1 / phi, power);
      } else {
        return baseRadius * Math.pow(phi, power);
      }
    }

    const stepsPerSegment = 40;
    const step = deltaTheta / stepsPerSegment;

    for (let k = 0; k < n; k++) {
      const baseAngle = (2 * Math.PI * k) / n;
      const hue = k / n;

      const mainColor    = new THREE.Color().setHSL(hue, 0.85, 0.6);
      const counterColor = new THREE.Color().setHSL(hue, 0.75, 0.35);

      // MAIN spiral (baseAngle + theta)
      const ptsMain = [];
      for (let theta = 0; theta <= maxTheta + 1e-6; theta += step) {
        const r   = radiusForTheta(theta);
        const ang = baseAngle + theta;
        const x   = r * Math.cos(ang);
        const z   = r * Math.sin(ang);
        const y   = isFlat ? 0 : -r / tanHalf; // flat mode = 2D
        ptsMain.push(new THREE.Vector3(x, y, z));
      }
      const geomMain = new THREE.BufferGeometry().setFromPoints(ptsMain);
      const matMain  = new THREE.LineBasicMaterial({ color: mainColor });
      spiralGroup.add(new THREE.Line(geomMain, matMain));

      // COUNTER spiral (baseAngle - theta)
      const ptsCounter = [];
      for (let theta = 0; theta <= maxTheta + 1e-6; theta += step) {
        const r   = radiusForTheta(theta);
        const ang = baseAngle - theta;
        const x   = r * Math.cos(ang);
        const z   = r * Math.sin(ang);
        const y   = isFlat ? 0 : -r / tanHalf;
        ptsCounter.push(new THREE.Vector3(x, y, z));
      }
      const geomCounter = new THREE.BufferGeometry().setFromPoints(ptsCounter);
      const matCounter  = new THREE.LineBasicMaterial({ color: counterColor });
      spiralGroup.add(new THREE.Line(geomCounter, matCounter));
    }
  }

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener("resize", onResize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  // Initial draw
  rebuild();
  animate();
</script>
</body>
</html>
